## 0 JVM架构

换个问法：说说JVM的组织架构

JVM主要分为三大部分

- 类加载器：将class文件读取到内存
- 运行时数据区：执行程序时用到的一块内存空间
- 执行引擎：执行字节码，还包括GC和JIT

## 1 Java类加载机制

### 1.1 类加载过程

分为5个阶段

加载：将字节码从jar包/class文件加载到内存中，按需加载，整个过程线程安全

验证：保障jvm安全的一步，校验二进制字节流格式、是否遵守访问权限（private、protected）、参数个数和类型等等

准备：静态变量初始化，分配内存并赋值

解析：符号引用解析为直接引用，类似逻辑地址解析为物理地址。动态绑定时，解析发生在初始化之后（因为需要根据对象实例解析）

初始化：执行构造方法

### 1.2 类初始化的时机

- 类实例化，new
- 反射调用
- 访问除了final的类静态成员
- 初始化一个类的子类，首先初始化其父类
- JVM启动加载main方法

### 1.3 JDK中内置的类加载器

- 引导类加载器（Bootstrap ClassLoader）：负责加载 JVM 基础核心类库，如 rt.jar、sun.boot.class.path 路径下的类。

- 扩展类加载器（Extension ClassLoader）：负责加载 Java 扩展库中的类，例如 jre/lib/ext 目录下的类或由系统属性 java.ext.dirs 指定位置的类。

- 应用类加载器（Application ClassLoader）：负责加载系统类路径 java.class.path 上指定的类库，通常是你的应用类和第三方库。

- 用户自定义类加载器：Java 允许用户创建自己的类加载器，通过继承 java.lang.ClassLoader 类的方式实现。这在需要动态加载资源、实现模块化框架或者特殊的类加载策略时非常有用。

### 1.4 双亲委派

当类加载器收到加载类或资源的请求时，首先判断之前是否加载过该class, 如果加载过直接返回。如果没有加载。就会委托给父类加载器加载去加载器，层层递归，一直到顶层父类加载器，启动类加载器，如果父类加载器也找不到，则自己去加载，最终自己也没有加载到会抛出`ClassNotFoundException`。

#### 1.4.1 双亲委派的好处

- 避免类的重复加载。当父加载器已经加载过某一个类时，子加载器就不会重新加载这个类。

- 安全性的考虑。比如我们的核心类库rt.jar是由启动类加载器`（BootstrapClassLoader）`加载的，采用双亲委派模型，可以避免有人自定义一个有破坏功能的java.lang.Integer被加载。这样可以有效的防止核心Java API被篡改。

#### 1.4.2 打破双亲委派例子

- SPI类加载
- Tomcat自定义的Web类加载器，用来隔离同一个Tomcat中运行的多个Web应用

### 1.5 静态绑定和动态绑定

绑定：可以理解成将符号引用解析为物理引用

- 静态绑定发生在**编译时期**，动态绑定发生在**运行时**
- 使用private或static或final修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。
- 静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。
- 重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成。

启示：尽量静态绑定，少用虚方法

## 2 JVM运行时数据区

- 程序计数器：线程私有，保存当前需要执行的指令地址，作用类似行号，每个线程维护一个以保证指令执行的顺序性。

- 虚拟机栈：线程私有，每个栈帧对应一个被调用的方法。当线程执行一个方法时，会创建一个对应的栈帧，并将栈帧压入栈中。当方法执行完毕后，将栈帧从栈中移除。
  - 栈帧
    - 局部变量表：存储方法中的局部变量
    - 操作数栈：保存计算过程中的中间结果
    - 动态链接：指向运行时常量池中该栈帧所属方法的引用，用于支持动态绑定
    - 方法返回地址：方法返回值
- 本地方法栈：与虚拟机栈类似，只不过虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。
- 堆：线程共享的一块内存区域，在 JVM 启动的时候创建，用来存储对象（数组也是一种对象）。
  - 字符串常量池：存放字符串常量

- 元空间：直接利用本地内存
  - 运行时常量池：包括类信息、字段信息、方法信息、接口信息、字符串常量等。注意和字节文件中的静态常量池区分开来


###  2.1 StackOverflowError

#### 2.1.1 什么是StackOverflowError

虚拟机栈中的栈帧数超过栈最大深度，就会抛出StackOverflowError

#### 2.1.2 什么时候会发生

- 递归调用层级过多
- 大循环（死循环）执行了过多方法，栈空间耗尽
- 局部变量声明过多，导致虚拟机栈最大深度变小
- native方法申请栈内存

#### 2.1.3 模拟StackOverflowError

递归调用

```java
public class StackOverflowTest {
    public static void main(String[] args) {
        method();
    }
    public static void method(){
        for(;;)
            method();
    }
}
```

循环依赖

```java
public class Component1 { 
    private Component2 component2;

    public Component1() {
        this.component2 = new Component2();
    }
}

public class Component2 {
    private Component1 component1;

    public Component2() {
        this.component1 = new Component1();
    }
}

public class Application {
    public static void main(String[] args) {
        // 无限循环导致栈溢出
        Component1 component1 = new Component1();
        // 无限循环导致栈溢出
        Component2 component2 = new Component2();
    }
}
```

#### 2.1.4 定位和解决手段

分两种情况

- 代码问题
  - 检查是否存在递归调用
  - 是否存在Spring Bean循环依赖，AOP是否隐藏了递归
- 非代码问题
  - 调大JVM栈内存临时止损（Xss参数）

#### 2.1.5 虚拟机栈最大深度

跟两个要素有关：JVM启动时分配的栈内存大小、栈帧大小

单个栈帧越大，最大深度越小

### 2.2 OutOfMemoryError

#### 2.2.1 为什么会发生

- 分配太少：JVM参数指定太少
- 内存泄漏：GC不掉

#### 2.2.1 三种OOM以及排查手段

- 堆OOM
  - 抛出时机：JVM尝试为对象申请内存时发现空间不足
  - 排查步骤
    - 【事前】启用JVM参数以捕获Heap Dump，保留OOM现场。最重要的是提前做好监控工作。
    - 【事发】止损：已经挂了先重启；暂时还正常运行的，扩容摘流量，保存现场，尝试在测试环境复现定位。
    - 【排查】jstat确认GC情况/或者先分析GC日志。jmap导出HeapDump文件，通过MAT、yCrash等工具离线分析。主要看两点：占用最多内存的对象及其GC Roots，定位到问题代码的位置。
- 元空间OOM
  - 抛出时机：MetaSpace 的已使用大小在持续增长，同时每次 GC 也无法释放，调大 MetaSpace 空间也无法彻底解决。
  - 原因：生成了大量动态类。元空间存储类的meta信息，类的数量越多，消耗内存越多。常见于突发大流量
  - 解决方案
    - 【事前】做好熔断限流等过载保护
    - 【止损】通过JVM参数调大元空间大小。元空间使用本地内存，容器扩容也可以止损。
    - 减少反射使用，框架已经用了很多了，这条其实很难说有效
- 堆外OOM
  - 抛出时机：堆外内存耗尽
  - 原因：Java直接操作堆外内存的手段只有两个，ByteBuffer和Unsafe的allocateMemory，常见于Netty、NIO相关组件
  - 排查：堆外OOM的排查已经脱离Java的范畴，更多需要从操作系统本身着手。一些工具：Perf，gperftools，gdb
    - 例子：[堆外内存排查](https://www.kancloud.cn/alex_wsc/javajvm/1844985)

### 2.4 相关问题

#### 2.4.1 为什么需要程序计数器？

CPU进行线程切换或者被其他工作打断之后再次回到线程执行的时候，需要知道上一次执行到哪个位置，而程序计数器就记录了程序执行的位置，所以可以快速的定位到上一次执行中断的位置，继续执行。

#### 2.4.2 为什么每个线程都需要一份私有的程序计数器？

一个进程中会有多个线程，并且各个线程之间可以进行频繁的切换，如果我们只用一个程序计数器可能会导致不同线程之间执行的字节码地址相互覆盖相互干扰，所以最好的解决办法就是么个线程都拥有一份程序计数器，各自急速正在执行的字节码地址。

## 3 垃圾回收

### 3.1 垃圾判断算法

- 引用计数法：无法解决循环依赖问题
- 可达性分析：从GC Roots开始搜索，不在引用链上的对象需要被GC
  - GC Roots
    - 虚拟机栈中的引用（方法的参数、局部变量等）
    - 本地方法栈中 JNI 的引用（句柄表）
    - 类静态变量
    - 运行时常量池中的常量（String 或 Class 类型）

### 3.2 OopMap

#### 3.2.1 什么是OopMap，作用？

在收集器枚举根节点的过程中，需要在一个保持**一致性的快照**中进行，否则对象的引用关系不断变化会导致结果的准确性缺失,所以在进行枚举时，所有的用户**线程必须停顿**。

可达性分析算法中从**GC Roots**中寻找**引用链**来判断对象是否存活 那GC Roots就需要时间去枚举，若收集器一个不漏的去查找栈的执行上下文和全局引用位置，就会过于耗时，所以虚拟机是能直接获取到**哪些地方存放着对象引用的** 这个地方就是**OopMap**，空间换时间的一种典型。

作用概括下就是，帮助JVM快速准确定位到GC Roots，并开展可达性分析。

#### 3.2.2 OopMap生成时机

- **类加载动作完成**：HotSpot 就会计算出对象内什么偏移量上是什么类型的数据(字段是基本数据类型还是引用数据类型)

- **即时编译**：判断在**安全点**下栈里和寄存器里哪些位置是引用

#### 3.2.3 OopMap更新时机

`OopMap` 的更新，从直观上来说，需要在对象**引用关系发生变化**的时候修改。

不过导致引用关系变化的指令非常多，如果对每条指令都记录 `OopMap` 的话 ，那将会需要大量的额外存储空间，空间成本就会变得无法忍受的高昂。选用一些特定的点来记录就能有效的缩小需要记录的数据量，这些特定的点就称为 **安全点 (Safepoint)**。

### 3.3 安全点（safe point）

#### 3.3.1 主动式中断

当 GC 回收需要停止用户线程的时候，将设置某个中断标志位，各个线程不断轮询这个标志位，发现需要挂起时，自己跑到最近的安全点，更新完 `OopMap` 才能挂起。

#### 3.3.2 安全区

解决block和sleep线程无法发起主动中断的问题。

安全区域指的是，在某段代码中，**引用关系不会发生变化**，线程执行到这个区域是可以安全停下进行 GC 的。因此，我们也可以把安全区域看做是扩展的安全点。

当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域。那样当这段时间里虚拟机要发起 GC 时，就不必去管这些在安全区域内的线程了。当线程要离开安全区域时，它要检查虚拟机是否处于 STW 状态，如果是，则需要等待直到恢复。

#### 3.3.3 为什么需要安全点

- 确保内存一致性：确保GC线程安全地修改内存，避免数据不一致
- 减少stw时间：将GC过程限制在安全点，避免JVM每执行一个指令都检查是否需要GC

#### 3.3.4 安全点设置在哪些地方

以程序”是否具有让程序长时间执行的特征“为标准进行选定的

- 方法入口和出口：调用方法和方法出口对应虚拟机栈中栈帧的压入和弹出，此时获取栈帧信息是非常自然的
- 循环体结尾
- 异常抛出时

### 3.4 Stop The World

JVM在GC之前发起STW，所有用户线程进入安全点（区）之后暂停。

#### 3.4.1 为什么需要STW

如果出现分析过程中对象引用关系还在不断变化，则可达性分析结果的准确性无法保证。



### 3.5 垃圾回收算法

基于标记的三种基础GC算法思想

- 标记清除
  - 优点：逻辑清晰好操作
  - 缺点：内存碎片
- 标记复制
  - 优点：避免了内存碎片
  - 缺点：空间利用率低

- 标记整理
  - 优点：避免了内存碎片且空间利用率高
  - 缺点：频繁变更内存，效率差

#### 3.5.1 分代收集算法



// todo

- 虚引用和cleaner