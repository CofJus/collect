1.【common】[局部性原理——各类优化的基石](https://cloud.tencent.com/developer/article/1777697)

处理器在访问某些数据时短时间内存在重复访问，某些数据或者位置访问的概率极大，大多数时间只访问*局部*的数据。基于局部性原理，计算机处理器在设计时做了各种优化。

2.【MySQL】[预读和预读失效](https://juejin.cn/post/7211120847787655227) 

线性预读：如果顺序的访问了一个区里的多个数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区中的所有数据页都加载到缓存里去。

普通LRU，预读的数据可能会把热数据从缓冲池挤出去。

[一文读懂 InnoDB 缓冲池(buffer pool) 工作原理](https://segmentfault.com/a/1190000022754487)

局部性原理 -> 磁盘按页加载 -> 线性预读 -> 避免预读失效对LRU性能的影响 -> LRU分old和new区（类似新生/老年代）

缓冲池污染：大量数据（全表扫描）一次性加载到缓冲池，导致热数据被冲掉，性能严重下滑

缓冲池污染优化：old区停留时间。old区短期内频繁被读取的页不移动到new区

3.【MySQL】[插入缓冲 提高非聚簇索引插入效率](https://juejin.cn/post/7260499321983696957)

（非聚簇索引存储在独立的数据里，不影响聚簇索引的查询，数据插入和索引插入是两回事）

非聚簇索引不连续自增&不唯一&数据离散，插入效率低

用insert buffer（本质也是一棵B+树）缓存待插入的非聚簇索引，合适的时机合并插入到索引中

4.【MySQL】[两次写](https://juejin.cn/post/7062894835220348965)

如果发生了写失效的情况，可以通过重做日志进行恢复，重做日志是对页的物理操作，如果这个页本身发生了损坏，再对其进行重做是没有意义的。在应用重做日志前，用户需要一个页的副本，当发生写失效的时候，先通过页的副本来还原页，在进行重做，这就是 `double write`。

